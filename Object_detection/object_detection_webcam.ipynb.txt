# ==============================================================================
# STEP 0: Install Dependencies
# ==============================================================================
!pip install ultralytics opencv-python --quiet
from IPython.display import display, Javascript, Image, clear_output
from google.colab.output import eval_js
import cv2
import numpy as np
from ultralytics import YOLO
import time
from base64 import b64decode, b64encode

# ==============================================================================
# STEP 1: Load YOLOv8 Model
# Using 'n' (nano) for better real-time speed in a browser environment
# ==============================================================================
model = YOLO("yolov8n.pt")

# ==============================================================================
# STEP 2: JavaScript Functions for Webcam Control
# ==============================================================================

# JavaScript to start the video stream and capture the latest frame as a base64 JPEG
def start_webcam_stream(quality=0.8):
  js = Javascript('''
    var video;
    var div = null;
    var stream;
    var canvas;
    var result = null;

    // 1. Setup video and canvas elements
    div = document.createElement('div');
    document.body.appendChild(div);

    video = document.createElement('video');
    video.style.display = 'none'; // Keep video element hidden
    div.appendChild(video);

    canvas = document.createElement('canvas');
    canvas.style.display = 'none'; // Keep canvas hidden
    div.appendChild(canvas);

    // 2. Start video stream using navigator.mediaDevices.getUserMedia
    navigator.mediaDevices.getUserMedia({video: true})
      .then(function(s) {
        stream = s;
        video.srcObject = stream;
        video.play();
      });
      
    // 3. Define function to capture and encode a frame
    window.captureFrame = function() {
      if (video.readyState === video.HAVE_ENOUGH_DATA) {
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        canvas.getContext('2d').drawImage(video, 0, 0, video.videoWidth, video.videoHeight);
        // Encode the frame as a high-quality JPEG (base64 string)
        result = canvas.toDataURL('image/jpeg', %f);
        return result;
      }
      return null;
    }

    // 4. Define function to stop the stream and clean up
    window.stopStream = function() {
        if (stream) {
            stream.getVideoTracks()[0].stop();
        }
        if (video) {
            video.remove();
        }
        if (div) {
            div.remove();
        }
    }
  ''' % quality)
  display(js)

# Python function to call the JavaScript capture function
def capture_frame():
  return eval_js('captureFrame()')

# Python function to decode the base64 string into an OpenCV image (numpy array)
def base64_to_image(base64_string):
  # Get the base64 part of the data URL (remove "data:image/jpeg;base64,")
  _, encoded = base64_string.split(',', 1)
  # Decode base64 to bytes
  jpeg_bytes = b64decode(encoded)
  # Convert bytes to a numpy array, then to an OpenCV image
  np_arr = np.frombuffer(jpeg_bytes, np.uint8)
  img = cv2.imdecode(np_arr, cv2.IMREAD_COLOR)
  return img

# ==============================================================================
# STEP 3: Main Detection Loop
# ==============================================================================

# Start the stream and wait for camera permission
print("Starting webcam feed... Please grant camera permission.")
start_webcam_stream()

# Use a loop to continuously process and display frames
try:
  # Set up a placeholder for the live output
  output_display = display(None, display_id=True)
  
  while True:
    # 1. Capture the frame (returns base64 string from JavaScript)
    frame_base64 = capture_frame()
    
    if frame_base64 is None:
      time.sleep(0.1) # Wait if the stream isn't ready
      continue

    # 2. Convert base64 string to OpenCV image format
    frame = base64_to_image(frame_base64)

    # 3. Run YOLOv8 prediction on the frame
    # verbose=False suppresses the detection logs for a cleaner output
    results = model.predict(frame, conf=0.25, verbose=False)
    
    # 4. Get the annotated frame (with boxes and labels)
    annotated_frame = results[0].plot()

    # 5. Convert the annotated OpenCV frame back to a JPEG byte string for display
    _, buffer = cv2.imencode('.jpeg', annotated_frame)
    jpeg_bytes = buffer.tobytes()

    # 6. Update the display with the new frame
    output_display.update(Image(data=jpeg_bytes))
    
    # Clear the notebook output to prevent a growing list of images
    # clear_output(wait=True) # Using output_display.update() is usually smoother

except KeyboardInterrupt:
  # This block runs when you manually press the 'Stop' button (square icon)
  print("\nDetection loop interrupted by user.")
except Exception as e:
  print(f"\nAn error occurred: {e}")

finally:
  # Ensure the JavaScript stream is stopped and cleaned up
  eval_js('stopStream()')
  print("Webcam stream stopped and resources cleaned up.")
